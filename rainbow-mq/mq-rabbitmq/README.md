RabbitMQ (SpringBoot整合构建高可用的消息传递方案)
===========

## RabbitMQ简单介绍

### AMQP核心概念

* Server: 又称Broker, 接收客户端的连接, 实现AMQP服务。
* Connection: 连接, 客户与Broker之间的网络连接。
* Channel: 网络信道, 几乎所有的操作都在Channel中进行, 包括定义Queue、定义Exchange、绑定Queue与Exchange、
发布消息等。Channel是进行消息读写的通道。客户端可以建立多个Channel, 每个Channel代表一个会话任务。
* Message: 消息, 服务器和应用程序之间传送的数据, 由properties和body组成。Properties可以对消息进行修饰, 比如
消息的优先级、延迟等高级特性;Body是消息体的内容。
* Virtual host: 虚拟地址, 用于进行逻辑隔离, 最上层的消息路由。一个Virtual host可以由若干个Exchange和Queue,
同一个Virtual host里面不能有相同的Exchange和Queue。
* Exchange: 交换机, 接收消息, 根据路由键转发消息到绑定的队列。RabbitMQ中有三种常用的交换机类型
    * direct: 如果路由键匹配, 消息就投递到对应的队列
    * fanout: 投递消息到绑定在此交换机上面的队列
    * topic: 允许实现有趣的消息通信场景，使得5不同源头的消息能够达到同一个队列。topic队列名称有两个特殊的关键字
* Binding: Exchange和Queue之间的虚拟连接, binding中可以包含routing key。
* Routing key: 一个路由规则, 虚拟机可用它来确定如何路由到一个特定消息。
* Queue: 也称为Message Queue, 消息队列, 保存消息并将它们转发给消费者。多个消费者可以订阅同一个消息队列, 这是
Queue中的消息会被平均分摊到多个消费者进行处理, 而不是每个消费者都收到所有的消息并处理。
* prefetch count: 如果有多个消费者订阅同一个Queue的消息, Queue中的消息会被平摊到多个消费者。这是如果每个消息的
处理时间不同, 就有可能导致某些消费者一直在忙, 而另外一些消费者很快处理完手头工作并一直空闲的情况。我们可以通过设置
prefetchCount=1, 则Queue每次给消费者发送一条消息;消费者处理完这条消息后Queue会再给该消费者发送一条消息。

## SpringBoot + RabbitMQ保证消息100%投递成功并被消费

### 一、前言

引入消息中间件的好处是起到抗高并发，削峰、业务解耦的作用

### 二、分析问题

```
// 发送订单消息
public Boolean sendOrderMessage() {
    // 客户端工具类发送消息
    RabbitTemplate template = new RabbitTemplate();
    
    try {
        // 发送消息
        template.send(orderMessage);
    } catch {
        return false;
    }
    return true;
}
```
参考上面的伪代码，消息服务返回成功真的就代表成功了吗？答案是否定的。如果MQ服务器突然宕机，订单服务发过去的消息都会消失
**一般MQ中间件为了提高系统的吞吐量会把消息保存在内存中，如果不做其他处理，MQ服务器一旦宕机，消息将全部丢失**。业务上是不允许的。

### 三、持久化

RabbitMQ可以设置消息可持久化。`durable`参数设置为true后就会把消息持久化到磁盘。这样的话MQ服务器即使宕机，重启后磁盘
文件中有消息的存储，这样在一定概率上保证了消息不丢失。但是有另外一个场景，消息刚刚保存到MQ内存中，但还没来得及更新到磁盘
文件中，突然宕机了。这种场景常出现在大量消息投递的过程中。那如何保证一定会持久化到磁盘上面呢？

### 四、confirm机制

RabbitMQ中有confirm机制可以通知我们持久化是否成功。

confirm原理：
> (1) 消息生产者把消息发送给MQ, 如果接收成功, MQ会返回一个ack消息给生产者  
> (2) 如果消息接收不成功, MQ会返回一个nack给生产者  
>
```
// 信道加入回调监听
channel.addConfirmListener(new ConfirmListener() {
    @Override
    public void handleNack() {
        log.info("==========消息接收不成功==========");
        // 进行不成功的处理
    }

    @Override
    public void handleAck() {
        log.info("==========消息接收成功==========");
        // 进行成功的处理
    }
});
```
如果生产者每发送一条消息，都要MQ持久化到磁盘中，然后在发起ack或nack回调。这样的话MQ的吞吐量不高，因为每次都要把
消息持久化到磁盘中。**MQ持久化磁盘真正实现, 是通过异步调用处理的。它的机制是等到有几千条消息的时候，会一次性地刷
盘到磁盘上面。而不是每来一条消息就刷盘一次。confirm机制其实是一个异步监听的机制, 保证了系统的高吞吐量。** 
即使是加上confirm机制,还是不能解决消息在MQ内存中还没有刷到磁盘中就宕机的问题。

### 五、消息提前持久化 + 定时任务

![补偿机制](http://47.111.248.7:10080/images/2021/01/21/_20210121112521.jpg)

上图流程：
> (1) 订单服务生产者在投递消息之前, 先把消息持久化到Redis, 消息状态为发送中  
> (2) confirm机制监听消息是否发送成功。如果收到ack消息, 删除redis中此消息  
> (3) 如果收到nack消息, 可以根据自身的业务选择是否要重发此消息或删除此消息  
> (4) 添加定时任务, 每隔一段时间查询所有消息为发送中的消息, 状态为发送中, 代表没有收到ack成功消息  
> (5) 定时任务会作为补偿性的投递消息。这个时候如果MQ回调ack成功接收了, 再把Redis中此消息删除掉  
>

这样的机制其实是一种补偿机制,不管MQ有没有正确地接收到消息,只要我的Redis的消息状态为发送中,就表示此消息没有正确成功投递。再启动定时任务去监控，
发起补偿投递。
当然定时任务那边还可以加上一个补偿的次数, 如果大于3次, 还是没有收到ack消息, 就直接把消息的状态改为失败。这样的方案就挺完美的, 保证了消息100%
不丢失。
这种方案的缺点是：可能发送多次相同的消息, 很可能MQ已经收到消息, ack消息回调时出现网络故障, 导致生产者没有收到消息。**这要求消费者在一定在消费
的时候保障幂等性**