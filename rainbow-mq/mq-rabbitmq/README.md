RabbitMQ
===========

### 一、前言

引入消息中间件的好处是起到抗高并发，削峰、业务解耦的作用

### 二、分析问题

```
// 发送订单消息
public Boolean sendOrderMessage() {
    // 客户端工具类发送消息
    RabbitTemplate template = new RabbitTemplate();
    
    try {
        // 发送消息
        template.send(orderMessage);
    } catch {
        return false;
    }
    return true;
}
```
参考上面的伪代码，消息服务返回成功真的就代表成功了吗？答案是否定的。如果MQ服务器突然宕机，订单服务发过去的消息都会消失
**一般MQ中间件为了提高系统的吞吐量会把消息保存在内存中，如果不做其他处理，MQ服务器一旦宕机，消息将全部丢失**。业务上是不允许的。

### 三、持久化

RabbitMQ可以设置消息可持久化。`durable`参数设置为true后就会把消息持久化到磁盘。这样的话MQ服务器即使宕机，重启后磁盘
文件中有消息的存储，这样在一定概率上保证了消息不丢失。但是有另外一个场景，消息刚刚保存到MQ内存中，但还没来得及更新到磁盘
文件中，突然宕机了。这种场景常出现在大量消息投递的过程中。那如何保证一定会持久化到磁盘上面呢？

### 四、confirm机制

RabbitMQ中有confirm机制可以通知我们持久化是否成功。

confirm原理：
> (1) 消息生产者把消息发送给MQ, 如果接收成功, MQ会返回一个ack消息给生产者
> (2) 如果消息接收不成功, MQ会返回一个nack给生产者
>
```
// 信道加入回调监听
channel.addConfirmListener(new ConfirmListener() {
    @Override
    public void handleNack() {
        log.info("==========消息接收不成功==========");
        // 进行不成功的处理
    }

    @Override
    public void handleAck() {
        log.info("==========消息接收成功==========");
        // 进行成功的处理
    }
});
```
如果生产者每发送一条消息，都要MQ持久化到磁盘中，然后在发起ack或nack回调。这样的话MQ的吞吐量不高，因为每次都要把
消息持久化到磁盘中。**MQ持久化磁盘真正实现, 是通过异步调用处理的。它的机制是等到有几千条消息的时候，会一次性地刷
盘到磁盘上面。而不是每来一条消息就刷盘一次。confirm机制其实是一个异步监听的机制, 保证了系统的高吞吐量。** 
即使是加上confirm机制,还是不能解决消息在MQ内存中还没有刷到磁盘中就宕机的问题。

### 五、消息提前持久化 + 定时任务

![补偿机制](http://47.111.248.7:10080/images/2021/01/21/_20210121112521.jpg)

上图流程：
> (1) 订单服务生产者在投递消息之前, 先把消息持久化到Redis, 消息状态为发送中
> (2) confirm机制监听消息是否发送成功。如果收到ack消息, 删除redis中此消息
> (3) 如果收到nack消息, 可以根据自身的业务选择是否要重发此消息或删除此消息
> (4) 添加定时任务, 每隔一段时间查询所有消息为发送中的消息, 状态为发送中, 代表没有收到ack成功消息
> (5) 定时任务会作为补偿性的投递消息。这个时候如果MQ回调ack成功接收了, 再把Redis中此消息删除掉
>

这样的机制其实是一种补偿机制,不管MQ有没有正确地接收到消息,只要我的Redis的消息状态为发送中,就表示此消息没有正确成功投递。再启动定时任务去监控，
发起补偿投递。
当然定时任务那边还可以加上一个补偿的次数, 如果大于3次, 还是没有收到ack消息, 就直接把消息的状态改为失败。这样的方案就挺完美的, 保证了消息100%
不丢失。
这种方案的缺点是：可能发送多次相同的消息, 很可能MQ已经收到消息, ack消息回调时出现网络故障, 导致生产者没有收到消息。**这要求消费者在一定在消费
的时候保障幂等性**